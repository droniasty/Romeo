

module AbsRomeo where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program a = Prog a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Prog a stmts -> Prog (f a) (map (fmap f) stmts)
data Stmt a
    = Empty a
    | Ass a Ident (Asg a) (Expr a)
    | Cond a (Expr a) [Stmt a] (ElIfs a)
    | CondElse a (Expr a) [Stmt a] (ElIfs a) [Stmt a]
    | While a (Expr a) [Stmt a]
    | For a Ident (Expr a) (Expr a) [Stmt a]
    | ForIn a Ident Ident [Stmt a]
    | Break a
    | Cont a
    | Func a Ident [Ident] [Stmt a]
    | Ret a (Expr a)
    | VRet a
    | Yeld a (Expr a)
    | Print a (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        Empty a -> Empty (f a)
        Ass a ident asg expr -> Ass (f a) ident (fmap f asg) (fmap f expr)
        Cond a expr stmts elifs -> Cond (f a) (fmap f expr) (map (fmap f) stmts) (fmap f elifs)
        CondElse a expr stmts1 elifs stmts2 -> CondElse (f a) (fmap f expr) (map (fmap f) stmts1) (fmap f elifs) (map (fmap f) stmts2)
        While a expr stmts -> While (f a) (fmap f expr) (map (fmap f) stmts)
        For a ident expr1 expr2 stmts -> For (f a) ident (fmap f expr1) (fmap f expr2) (map (fmap f) stmts)
        ForIn a ident1 ident2 stmts -> ForIn (f a) ident1 ident2 (map (fmap f) stmts)
        Break a -> Break (f a)
        Cont a -> Cont (f a)
        Func a ident idents stmts -> Func (f a) ident idents (map (fmap f) stmts)
        Ret a expr -> Ret (f a) (fmap f expr)
        VRet a -> VRet (f a)
        Yeld a expr -> Yeld (f a) (fmap f expr)
        Print a expr -> Print (f a) (fmap f expr)
data Item a = Init a Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Item where
    fmap f x = case x of
        Init a ident expr -> Init (f a) ident (fmap f expr)
data ElIfs a = CondElIfs a (ElIf a) (ElIfs a) | NilElif a
  deriving (Eq, Ord, Show, Read)

instance Functor ElIfs where
    fmap f x = case x of
        CondElIfs a elif elifs -> CondElIfs (f a) (fmap f elif) (fmap f elifs)
        NilElif a -> NilElif (f a)
data ElIf a = CondElIf a (Expr a) [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor ElIf where
    fmap f x = case x of
        CondElIf a expr stmts -> CondElIf (f a) (fmap f expr) (map (fmap f) stmts)
data List a
    = Lis1 a [Expr a]
    | Lis2 a (Expr a) (Expr a)
    | Lis3 a (Expr a) Ident (Expr a) (Expr a)
    | Lis4 a (Expr a) Ident Ident
  deriving (Eq, Ord, Show, Read)

instance Functor List where
    fmap f x = case x of
        Lis1 a exprs -> Lis1 (f a) (map (fmap f) exprs)
        Lis2 a expr1 expr2 -> Lis2 (f a) (fmap f expr1) (fmap f expr2)
        Lis3 a expr1 ident expr2 expr3 -> Lis3 (f a) (fmap f expr1) ident (fmap f expr2) (fmap f expr3)
        Lis4 a expr ident1 ident2 -> Lis4 (f a) (fmap f expr) ident1 ident2
data Expr a
    = EVar a Ident
    | ELitInt a Integer
    | ELitLis a (List a)
    | ELitTrue a
    | ELitFalse a
    | EApp a Ident [Expr a]
    | EGen a Ident
    | ETake a Ident
    | ESlice a Ident (Expr a) (Expr a)
    | EAnon a [Ident] (Expr a)
    | EString a String
    | EElem a Ident (Expr a)
    | Neg a (Expr a)
    | Not a (Expr a)
    | Pow a (Expr a) (Expr a)
    | EMul a (Expr a) (Expr a)
    | EDiv a (Expr a) (Expr a)
    | EMod a (Expr a) (Expr a)
    | EAdd a (Expr a) (Expr a)
    | ESub a (Expr a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EVar a ident -> EVar (f a) ident
        ELitInt a integer -> ELitInt (f a) integer
        ELitLis a list -> ELitLis (f a) (fmap f list)
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        EApp a ident exprs -> EApp (f a) ident (map (fmap f) exprs)
        EGen a ident -> EGen (f a) ident
        ETake a ident -> ETake (f a) ident
        ESlice a ident expr1 expr2 -> ESlice (f a) ident (fmap f expr1) (fmap f expr2)
        EAnon a idents expr -> EAnon (f a) idents (fmap f expr)
        EString a string -> EString (f a) string
        EElem a ident expr -> EElem (f a) ident (fmap f expr)
        Neg a expr -> Neg (f a) (fmap f expr)
        Not a expr -> Not (f a) (fmap f expr)
        Pow a expr1 expr2 -> Pow (f a) (fmap f expr1) (fmap f expr2)
        EMul a expr1 expr2 -> EMul (f a) (fmap f expr1) (fmap f expr2)
        EDiv a expr1 expr2 -> EDiv (f a) (fmap f expr1) (fmap f expr2)
        EMod a expr1 expr2 -> EMod (f a) (fmap f expr1) (fmap f expr2)
        EAdd a expr1 expr2 -> EAdd (f a) (fmap f expr1) (fmap f expr2)
        ESub a expr1 expr2 -> ESub (f a) (fmap f expr1) (fmap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (fmap f expr1) (fmap f relop) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
data Asg a = Eq a | PlEq a | MnEq a | MulEq a | DivEq a | PowEq a
  deriving (Eq, Ord, Show, Read)

instance Functor Asg where
    fmap f x = case x of
        Eq a -> Eq (f a)
        PlEq a -> PlEq (f a)
        MnEq a -> MnEq (f a)
        MulEq a -> MulEq (f a)
        DivEq a -> DivEq (f a)
        PowEq a -> PowEq (f a)
data AddOp a = Plus a | Minus a
  deriving (Eq, Ord, Show, Read)

instance Functor AddOp where
    fmap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)
data MulOp a = Times a | Div a | Mod a
  deriving (Eq, Ord, Show, Read)

instance Functor MulOp where
    fmap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        Mod a -> Mod (f a)
data RelOp a = LTH a | LE a | GTH a | GE a | EQU a | NE a
  deriving (Eq, Ord, Show, Read)

instance Functor RelOp where
    fmap f x = case x of
        LTH a -> LTH (f a)
        LE a -> LE (f a)
        GTH a -> GTH (f a)
        GE a -> GE (f a)
        EQU a -> EQU (f a)
        NE a -> NE (f a)
